# Chcemy doporowadzić do sytuacji w której wszystko znajduje się na wschodnim brzegu
#
# Klasa transfer określa dwie rzeczy - załadunek łódki oraz jej kierunek
#
# Z każdym kursem musi być wygenerowany set możliwych kombinacji pasażerów który nie zagraża życiu zwierzaków
# Jeżeli dwa kursy pod rząd zaproponują żeby nie zabierać niczego to skrypt jest przerywany błędem - "pat"
# Jeżeli skrypt zaczyna się zapętlać i cyklicznie powatarzać kursy to również zakończy się błędem
# Skrypt nie może doprowadzić do sytuacji w której zawożąc zwierzę na jeden brzeg, zabierze to samo zwierze z powrotem
# Unikalne id pozwalają na odróżnienie zwierząt tego samego rodzaju
# Jeżeli więcej niż jedna z kombinacji pozwala na przewóz zwierzątka to skrypt przetestuje wszystkie możliwe sytuacje
# aż nie dojdzie to sytuacji w której na prawym brzegu znajdzie się cały inwentarz
#
# Model z kombinacjami i "drzewkiem decyzyjnym" sugeruje użycie grafów

# Węzłami w grafie są kolejne kombinacje pasażerów, postępują tylko te ścieżki które nie kolidują z zależnościami
# kto zjada kogo
#
# Grafy tworzone z pomocą pakietu Networkx, który pozwala na łatwą integrację kolejnych węzłów
#
# Każdy węzeł cechuje się id któremu odpowiada odpowiedni załadunek na łódce
#
# Dzięki pakietowi Networkx można generować wierzchołki grafu, tzw. liście
# Trzeba napisać funkcję która skacze po liściach i dodaje kolejne kroki tylko do tych, które nie są błędami
#
#

import copy
import sys
import itertools
import networkx as nx
import matplotlib.pyplot as plt
import random


# Creating class for each course, with unique id and direction
# Direction: - True = transfer to east shore
#           - False = transfer to west shore
# Creating a powerset from given set of objects.
def powerset(s):
    x = len(s)
    masks = [1 << i for i in range(x)]
    for i in range(1 << x):
        yield [ss for mask, ss in zip(masks, s) if i & mask]

# Defining class for each transfer with two attributes: name - passengers and direction.
class Transfer:
    new_id = itertools.count()

    def __init__(self, name: list, direction: int):
        self.name = name
        self.id = next(self.new_id)
        self.direction = direction


class Shore:

    def __init__(self, inv: dict):
        self.inv = inv

    # Subtracting number of animals on given shore.
    def minus(self, passengers):
        list_of_passengers = [i for i in passengers]
        for i in list_of_passengers:
            self.inv[i] = self.inv[i] - 1
            if self.inv[i] < 0:
                raise Exception('Number of animals became less than 0')
        return self.inv

    # Adding number of animals to given shore.
    def plus(self, passengers):
        list_of_passengers = [i for i in passengers]
        for i in list_of_passengers:
            self.inv[i] = self.inv[i] + 1
        return self.inv

    # Function returning boolean value depending on eating habits and current state of given shore.
    # If farmer is not paying attention to the given shore, some animals might get hungry.
    # Should there be a health hazard for any animal, function will return adequate result.
    def frenzy_check(self):
        list_of_keys = list(habits.keys())
        list_of_values = copy.deepcopy(list(habits.values()))
        vore = []
        for i in list_of_values:
            for j in i:
                element = [j, list_of_keys[list_of_values.index(i)]]
                vore.append(element)
        all_comb = powerset(self.create_shore_list())
        unique = [list(x) for x in set(tuple(x) for x in all_comb)]
        animal_pairs = [sorted(i) for i in sorted(unique) if len(i) == 2]
        for i in vore:
            if sorted(i) in animal_pairs:
                return False
            else:
                pass
        return True

    # Creating full list of animals on shore from shore dictionary for further combination.
    def create_shore_list(self):
        current_shore = []
        for i in self.inv:
            for j in range(self.inv[i]):
                current_shore.append(i)
        return current_shore

    # Combinating all possible configurations of passangers that might leave given shore.
    # Empty boat is taken into account. Any combinations that exceed boat capacity are discarded.
    def possible_passengers(self):
        all = powerset(self.create_shore_list())
        unique = [list(x) for x in set(tuple(x) for x in all)]
        passenger_combinations = [i for i in sorted(unique) if len(i) < cap]
        return passenger_combinations

    # Creating empty, east shore
    def create_empty_shore(self):
        blank = {k: 0 for k in self.inv}
        return Shore(blank)


# Loading a file and preparing for further use.
def load_file(a=sys.argv[1]):
    pre = open(a, 'r').readlines()
    sep = [i.strip('\n').split(" ") for i in pre]
    return sep


f = load_file()

# Defining capacity of a boat, default capacity is set at 2.
if sys.argv[2]:
    cap = int(sys.argv[2])
else:
    cap = 2

global habits
habits = {}


# Loading info about number of animals on starting shore and their eating habits from file.
def load_dicts(fn):
    start = {}
    for i in fn:
        if len(i) > 1:
            if not i[0].isdigit():
                k = i[0]
                v = i[1:]
                habits[k] = v
        if len(i) == 2:
            if i[0].isdigit():
                k = i[1]
                v = int(i[0])
                start[k] = v
        elif len(i) == 1:
            k = i[0]
            start[k] = 1
    return start

# Checking history allows us to spot possible loops. Function forbids repeating same shore patterns with same
# passengers on board.
def check_history(node, course, c_shore, o_shore):
    check_in = {str(c_shore.inv): str(o_shore.inv)}
    if sorted(course.name) in list(G.nodes[node]['name_history']) and \
            list(check_in.items())[0] in list(G.nodes[node]['shore_history'].items()):
        return False
    else:
        return True

# Returns all leaf nodes that aren't already completed in some way or are initial node.
leaf_labels = [['ZAPĘTLENIE'], ['POŻARCIE'], ['KONIEC'], ['POCZĄTEK']]
def return_leafs(graph):
    leaf_nodes = [node for node in graph.nodes() if graph.degree(node) == 1 and graph.nodes[node]['label'] not in leaf_labels ]
    # if 0 in leaf_nodes:
    #     leaf_nodes.remove(0)
    return leaf_nodes

w_shore = Shore(load_dicts(f))
e_shore = w_shore.create_empty_shore()
G = nx.Graph()
# Stating our goal for number of animals on east shore
goal = copy.deepcopy(w_shore)
node_sizes = {} # Creating dictionary to store and then modify size of given nodes


# And the journey has begun

# Initializing graph with starting node and first possible transfers.
G.add_node(0, label=['POCZĄTEK'], state=[w_shore, e_shore])
node_sizes[0]=50

for possibility in G.nodes[0]['state'][0].possible_passengers():
    course = Transfer(possibility, 1)
    current_shore = copy.deepcopy(G.nodes[0]['state'][0])
    other_shore = copy.deepcopy(G.nodes[0]['state'][1])
    current_shore.minus(course.name)
    other_shore.plus(course.name)
    if current_shore.frenzy_check():
        G.add_node(course.id, label=course.name,
                   direction=course.direction,
                   state=[current_shore, other_shore],
                   shore_history={str(current_shore.inv): str(other_shore.inv)},
                   name_history=[list(course.name)])
        node_sizes[course.id] = 50
        G.add_edge(0, course.id)

    else:
        smallish = random.random()
        G.add_node(smallish, label=['POŻARCIE'])
        G.add_edge(0, smallish)
        node_sizes[smallish] = 50

# Acquiring first possible path ways.
leaf_nodes = return_leafs(G)
# Creating list with already visited nodes so that script doesn't check them again.
no_repetitions = []

# Script will jump around leaf nodes until there aren't any left that were either visited or labeled as error or
# meeting goal.
while leaf_nodes:
    for i in leaf_nodes:
            current_shore = copy.deepcopy(G.nodes[i]['state'][1]) # Repositioning shore so that with each iteration
            other_shore = copy.deepcopy(G.nodes[i]['state'][0])   # boat can transfer between shores.
            if G.nodes[i]['direction'] == (-1):
                break_point = goal.inv          # Specifing what kind of shore inventory should trigger end node,
            else:                               # depending in which direction the boat is currently heading.
                break_point = e_shore.inv
            if other_shore.inv != break_point:
                for possibility in current_shore.possible_passengers():
                    if G.nodes[i]['direction'] == (-1): # Changing direction of the boat.
                        course = Transfer(possibility, 1)
                    else:
                        course = Transfer(possibility, (-1))
                    c_shore = copy.deepcopy(current_shore)  # Ensuring that the shore inventory is changed just for
                    o_shore = copy.deepcopy(other_shore)    # path we're currently on.
                    c_shore.minus(course.name)
                    o_shore.plus(course.name)
                    c = str(c_shore.inv)
                    o = str(o_shore.inv)
                    reference = copy.deepcopy(G.nodes[i]['shore_history'])
                    reference.update({c: o}) # Storing data about previous steps within same path.
                    if course.name == [] and G.nodes[i]['label'] == []: # Preventing from cruising with empty boat
                        pass                                            # back and forth
                    else:
                        if c_shore.frenzy_check(): # Caring about animals
                            if check_history(i, course, c_shore, o_shore): # Caring about history
                                G.add_node(course.id, # Finally adding a node to the graph, node number should be unique
                                           label=course.name, # course.id.
                                           direction=course.direction,
                                           state=[c_shore, o_shore],
                                           shore_history=reference)
                                if len(course.name) > 1: # Depending on boat capacity there had to be different name
                                    G.nodes[course.id]['name_history'] = list( # history storing techniques
                                        G.nodes[i]['name_history'] + [sorted(course.name)])
                                elif len(course.name) == 1:
                                    G.nodes[course.id]['name_history'] = list(
                                        G.nodes[i]['name_history'] + [[i] for i in sorted(course.name)])
                                else:
                                    G.nodes[course.id]['name_history'] = list(G.nodes[i]['name_history'])
                                G.add_edge(i, course.id) # Connecting nodes
                                node_sizes[course.id] = 50
                            else:
                                smallish = random.random() # Creating float number so it can be distinguished from others
                                G.add_node(smallish, label=['ZAPĘTLENIE'])
                                G.add_edge(i, smallish)
                                no_repetitions.append(smallish)
                                node_sizes[smallish]=50
                        else:
                            smallish = random.random()
                            G.add_node(smallish, label=['POŻARCIE'])
                            G.add_edge(i, smallish)
                            no_repetitions.append(smallish)
                            node_sizes[smallish] = 50
            else:
                G.add_node((-1) * i, label=['KONIEC']) # Negative id will highlight goal nodes
                G.add_edge(i, (-1) * i)
                no_repetitions.append((-1) * i)
                node_sizes[(-1)*i] = 50
            no_repetitions.append(i)
    leaf_nodes = return_leafs(G) # Finding new leaf nodes.
    leaf_nodes = set(leaf_nodes) - set(no_repetitions)


# Making list of all node labels for future reference
list_of_labels = [G.nodes[i]['label'] for i in G.nodes()]

# Identifing goal nodes
end_points = [i for i in G.nodes() if i < 0]

# Just as the name suggest - it finds all shortest paths, if those are equal it'll choose one
def find_shortest(list_of_ends):
    all_paths = [nx.bidirectional_shortest_path(G, 0, i) for i in list_of_ends]
    return min(all_paths, key=len)

color_map = []

# Printing out final result and also highliting nodes in shortest path to goal
if ['KONIEC'] in list_of_labels:
    shortest_path = find_shortest(end_points)
    for node in G:
        if node in shortest_path:
            color_map.append('green')
            node_sizes[node] = 1000
        else:
            color_map.append('red')
    for i in shortest_path:
        print(G.nodes[i]['label'], end=' ')
else:
    print('NIEMOŻLIWE')

list_of_node_sizes = [node_sizes[k] for k in node_sizes]

# Drawing a graph and saving it as a .png file
labels = dict((n, d['label']) for n, d in G.nodes(data=True))
plt.figure(figsize=(20, 10))
nx.draw(G, labels=labels, font_size = 5 ,node_color=color_map, node_size=list_of_node_sizes, with_labels=True, node_shape='D', legend='label')
plt.savefig("graph1.png")
